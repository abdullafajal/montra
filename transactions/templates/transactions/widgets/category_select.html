{% load static %}
<div class="relative custom-select-container" id="container-{{ widget.name }}">
    <!-- Original Hidden Select (Django binds to this) -->
    <select name="{{ widget.name }}" id="{{ widget.attrs.id }}" class="hidden" onchange="updateCustomSelectDisplay('{{ widget.name }}')">
        {% for group in widget.optgroups %}
            {% for option in group.1 %}
                <option value="{{ option.value }}" {% if option.selected %}selected{% endif %}>{{ option.label }}</option>
            {% endfor %}
        {% endfor %}
    </select>

    <!-- Custom Trigger Button -->
    <button type="button" 
            class="w-full flex items-center justify-between px-4 py-3 text-left bg-m3-surface-container-high dark:bg-m3-surface-container-high-dark border border-m3-outline-variant dark:border-m3-outline-variant-dark rounded-xl focus:ring-2 focus:ring-m3-primary transition-all group"
            onclick="toggleCustomSelect('{{ widget.name }}')">
        
        <div class="flex items-center gap-3" id="display-{{ widget.name }}">
            <span class="text-m3-on-surface dark:text-m3-on-surface-dark opacity-70">Select Category</span>
        </div>
        
        <span class="material-symbols-outlined text-m3-outline dark:text-m3-outline-dark transition-transform duration-200 group-aria-expanded:rotate-180">expand_more</span>
    </button>

    <!-- Custom Options List -->
    <div class="hidden absolute left-0 right-0 top-full mt-1 z-50 max-h-60 overflow-y-auto bg-m3-surface-container-high dark:bg-m3-surface-container-high-dark border border-m3-outline-variant dark:border-m3-outline-variant-dark rounded-xl shadow-xl animate-scale-in"
         id="options-{{ widget.name }}">
         
        {% for cat in categories %}
        <div class="flex items-center gap-3 px-4 py-3 cursor-pointer hover:bg-m3-surface-container-highest dark:hover:bg-m3-surface-container-highest-dark transition-colors border-b border-m3-outline-variant/10 dark:border-m3-outline-variant-dark/10 last:border-0"
             onclick="selectCustomOption('{{ widget.name }}', '{{ cat.id }}', '{{ cat.name|escapejs }}', '{{ cat.icon }}', '{{ cat.color }}')">
            <div class="w-8 h-8 rounded-lg flex items-center justify-center shrink-0" style="background-color: {{ cat.color }}20;">
                <span class="material-symbols-outlined" style="color: {{ cat.color }}; font-size: 18px;">{{ cat.icon }}</span>
            </div>
            <span class="text-sm font-medium text-m3-on-surface dark:text-m3-on-surface-dark truncate">{{ cat.name }}</span>
            
            <!-- Checkmark for selected state (handled by JS) -->
            <span class="material-symbols-outlined text-m3-primary dark:text-m3-primary-dark ml-auto opacity-0 check-{{ cat.id }}" style="font-size: 18px;">check</span>
        </div>
        {% endfor %}
    </div>
</div>

<script>
    // Initialize
    document.addEventListener("DOMContentLoaded", function() {
        const name = '{{ widget.name }}';
        const select = document.getElementById('{{ widget.attrs.id }}');
        
        // Initial setup if value exists
        if (select.value) {
            // Find the category object from the list corresponding to this value
            // We use the rendered options to find data
            const catId = select.value;
            // Iterate through our rendered category data to find the matching one
            // Since we can't easily loop JS over template context in script tag without json_script
            // We will rely on the selectCustomOption logic trigger by finding the option div
            // Actually, cleaner way:
            const options = document.querySelectorAll(`#options-${name} > div`);
            options.forEach(opt => {
                if (opt.getAttribute('onclick').includes(`'${catId}'`)) {
                    opt.click(); // Trigger click to set display
                    // But we don't want to re-trigger select change event loops or close dropdown if not open
                    // Let's just manually update display
                    // Actually, simpler: just let updateDisplayFromValue handle it
                    updateCustomSelectDisplay(name, catId);
                }
            });
        }
        
        // Close on click outside
        document.addEventListener('click', function(e) {
            const container = document.getElementById(`container-${name}`);
            if (!container.contains(e.target)) {
                document.getElementById(`options-${name}`).classList.add('hidden');
            }
        });
    });

    function toggleCustomSelect(name) {
        const options = document.getElementById(`options-${name}`);
        options.classList.toggle('hidden');
    }

    function selectCustomOption(name, value, label, icon, color) {
        const select = document.querySelector(`select[name="${name}"]`);
        select.value = value;
        select.dispatchEvent(new Event('change')); // Notify Django form
        
        // Update UI
        const display = document.getElementById(`display-${name}`);
        display.innerHTML = `
            <div class="w-6 h-6 rounded flex items-center justify-center shrink-0" style="background-color: ${color}20;">
                <span class="material-symbols-outlined" style="color: ${color}; font-size: 16px;">${icon}</span>
            </div>
            <span class="text-sm font-medium text-m3-on-surface dark:text-m3-on-surface-dark">${label}</span>
        `;
        
        // Hide dropdown
        document.getElementById(`options-${name}`).classList.add('hidden');
        
        // Update checkmarks
        document.querySelectorAll(`#options-${name} .opacity-100`).forEach(el => el.classList.remove('opacity-100'));
        document.querySelectorAll(`#options-${name} .opacity-100`).forEach(el => el.classList.add('opacity-0'));
        
        const check = document.querySelector(`#options-${name} .check-${value}`);
        if(check) {
            check.classList.remove('opacity-0');
            check.classList.add('opacity-100');
        }
    }
    
    function updateCustomSelectDisplay(name, value) {
         // Logic to find option data by value if we didn't click it
         // This is a backup for initial load. 
         // For now, the loop in DOMContentLoaded suffices implicitly if we iterate choices.
    }
</script>
